#!/usr/bin/env python3

import time
import os.path
import pprint
import fnmatch
import threading
import yaml
import argparse
import pyexiv2
import xmltodict
from colorama import Fore, Style
from watchdog.observers import Observer
from watchdog.events import PatternMatchingEventHandler

LR_SUBJECT_TAG = 'Xmp.lr.hierarchicalSubject'
ACDSEE_CATEGORIES_TAG = 'Xmp.acdsee.categories'
PERSON_TAG = 'Xmp.iptcExt.PersonInImage'
EVENT_TAG = 'Xmp.iptcExt.Event'
SUBJECT_TAG = 'Xmp.dc.subject'
KEYWORDS_TAG = 'Xmp.acdsee.keywords'

COLORS = {
    'red': Fore.RED,
    'green': Fore.GREEN,
    'yellow': Fore.YELLOW,
    'magenta': Fore.MAGENTA,
    'cyan': Fore.CYAN,
}
STYLES = {
    'bold': Style.BRIGHT,
}

pp = pprint.PrettyPrinter(indent=4)
changed_files = set()
changed_config = False
changed_files_lock = threading.Lock()


# Read out the command line.
parser = argparse.ArgumentParser(prog="acdsee-helper")
parser.add_argument("-b", "--base", action="store",
                    help="base directory to monitor")
parser.add_argument("-c", "--config", action="store",
                    help="config file to use")
parser.add_argument("-d", "--dry-run", action="store_true",
                    help="don't really do any work")
parser.add_argument("-n", "--no-color", action="store_true",
                    help="don't use colours")
parser.add_argument("-v", "--verbose", action="count", default=0,
                    help="turn on more output")
parser.add_argument("-x", "--dump-xmp", action="store_true",
                    help="just dump xmp")
parser.add_argument("filename", nargs="*",
                    help="files to update, no files enters watching mode")
args = parser.parse_args()

base = args.base
verbose = args.verbose
dry_run = args.dry_run
no_color = args.no_color
dump_xmp = args.dump_xmp
file_names = args.filename
config_file = args.config


class Config:

    def __init__(self, file_name):
        self._file_name = file_name
        self._config = {}
        self._people = {}
        self.load()

    def _build_people_map(self, entries, depth=0, base=None):
        if base is None:
            base = []
        if depth == 0:
            self._build_people_map(entries['people'], 1, ['People'])
            return
        for entry in entries:
            if type(entry) is dict:
                for sub_entry in entry:
                    self._build_people_map(entry[sub_entry], depth + 1, base + [sub_entry])
            else:
                self._people[entry.lower()] = '|'.join(base + [entry])

    def load(self):
        if self._file_name is not None:
            with open(self._file_name, 'r') as config_file:
                try:
                    self._config = yaml.safe_load(config_file)
                except yaml.YAMLError as exc:
                    print(color(f'failed to read config: {exc}', fg="red"))
        if 'people' in self._config:
            self._build_people_map(self._config)

    def people_to_keywords(self, entries, depth=0):
        if depth == 0:
            print(self.people_prefix)
            self.people_to_keywords(entries['people'], 1)
            return
        for entry in entries:
            if type(entry) is dict:
                for sub_entry in entry:
                    print(('\t' * depth) + sub_entry)
                    self.people_to_keywords(entry[sub_entry], depth + 1)
            else:
                print(('\t' * depth) + entry)

    def name_to_keywords(self, name):
        return self._people.get(name.lower(), None)

    @property
    def event_category(self):
        return self._config.get('global', {}).get('event-category', 'Events')

    @property
    def people_prefix(self):
        return self._config.get('global', {}).get('people-prefix', 'People')

    @property
    def unknown_prefix(self):
        return self._config.get('global', {}).get('unknown-prefix', 'Unknown')

    @property
    def file_patterns(self):
        return self._config.get('global', {}).get('file-patterns',
                                                  ["*.xmp", "*.tif", "*.tiff", "*.jpg", "*.jpeg"])


class ExifFileHandler(PatternMatchingEventHandler):

    def __init__(self, config):
        super().__init__()
        self._config = config

    def is_match(self, event):
        src = event.src_path.lower()
        for pattern in self._config.file_patterns:
            if fnmatch.fnmatch(src, pattern):
                return True
        return False

    def on_modified(self, event):
        if self.is_match(event):
            with changed_files_lock:
                global changed_files
                changed_files.add(event.src_path)

    def on_closed(self, event):
        if self.is_match(event):
            with changed_files_lock:
                global changed_files
                changed_files.add(event.src_path)


class ConfigFileHandler(PatternMatchingEventHandler):

    def __init__(self, config):
        super().__init__()
        self._config = config

    def on_modified(self, event):
        with changed_files_lock:
            global changed_config
            changed_config = True

    def on_closed(self, event):
        with changed_files_lock:
            global changed_config
            changed_config = True


def color(msg, fg=None, style=None):
    if no_color:
        return msg
    colors = ""
    if fg is not None and fg in COLORS:
        colors = COLORS[fg]
    if style is not None and style in STYLES:
        colors = colors + STYLES[style]
    return colors + msg + Style.RESET_ALL


def remove_duplicates(messy_list):
    return list(dict.fromkeys(messy_list))


def file_age(filepath):
    return time.time() - os.path.getmtime(filepath)


def acdsee_region_entry(i, entry):
    return f'Xmp.acdsee-rs.Regions/acdsee-rs:RegionList[{i}]/acdsee-rs:{entry}'


def _get_event(category):
    if category.get('@Assigned', '0') != '0':
        return category.get('#text', None)
    next_category = category.get('Category', None)
    if next_category is None:
        return None
    return _get_event(next_category)


def get_event(_config, exif):
    categories = exif.get(ACDSEE_CATEGORIES_TAG, '')
    if len(categories) > 0:
        try:
            for key, value in xmltodict.parse(categories)['Categories'].items():
                if value.get('#text', '') == 'Events':
                    event = _get_event(value)
                    if event is not None:
                        return event
        except Exception as e:
            print(color(f'failed to read category: {str(e)}', fg="red"))
    return None


unknowns = set()


def reset_unknown_people():
    global unknowns
    unknowns = set()


def _parse_area(config, exif):
    global unknowns
    people = []
    keywords = []
    i = 1
    while acdsee_region_entry(i, 'Type') in exif:
        if exif[acdsee_region_entry(i, 'Type')].lower() == 'face':
            name = exif[acdsee_region_entry(i, 'Name')]
            keyword = config.name_to_keywords(name)
            people.append(name)
            if keyword is not None:
                keywords.append(keyword)
            else:
                if name not in unknowns:
                    unknowns.add(name)
                    print(color(f" missing person config for {name}", fg='yellow'))
                keywords.append(f'{config.people_prefix}|{config.unknown_prefix}|{name}')
        i = i + 1
    return people, keywords


def get_people_in_image(config, exif):
    people = []
    for keyword in exif.get(KEYWORDS_TAG, []):
        topics = keyword.split('|')
        if topics[0].lower() == config.people_prefix.lower():
            people.append(topics[-1])

    apeople, akeywords = _parse_area(config, exif)
    people = remove_duplicates(people + apeople)
    return people


def get_keywords(config, exif):
    keywords = exif.get(KEYWORDS_TAG, [])

    apeople, akeywords = _parse_area(config, exif)
    keywords = remove_duplicates(keywords + akeywords)
    return keywords


def get_subjects(config, exif):
    subjects = []
    for keyword in get_keywords(config, exif):
        subjects.append(keyword.split('|')[-1])
    return remove_duplicates(subjects)


def dump_meta_data(file):
    image = pyexiv2.Image(file)
    data = image.read_xmp()
    pp.pprint(data)


def tidy_meta_data(config, file):
    image = pyexiv2.Image(file)
    data = image.read_xmp()

    # Act on a file.
    print(color(f"{os.path.basename(file)}: processing", style='bold', fg='green'))

    # Save current values
    old_changes = {}
    for keyword in [LR_SUBJECT_TAG, PERSON_TAG, EVENT_TAG, SUBJECT_TAG]:
        if keyword in data:
            old_changes[keyword] = data[keyword]

    # Now grab some new values.
    changes = {}
    event = get_event(config, data)
    people = get_people_in_image(config, data)
    keywords = get_keywords(config, data)
    subjects = get_subjects(config, data)

    # Do the updates. To stop doing too much work we only write out
    # when something has really changed.

    # Fill in or clear out the changes.
    if not keywords:
        if LR_SUBJECT_TAG in data:
            if verbose:
                print(color(f" removing {LR_SUBJECT_TAG}", fg='magenta'))
            if not dry_run:
                image.modify_xmp({LR_SUBJECT_TAG: None})
    else:
        changes[LR_SUBJECT_TAG] = remove_duplicates(keywords)

    if not subjects:
        if SUBJECT_TAG in data:
            if data[SUBJECT_TAG] != ['']:
                if verbose:
                    print(color(f" removing {SUBJECT_TAG}", fg='magenta'))
                if not dry_run:
                    image.modify_xmp({SUBJECT_TAG: ""})
    else:
        changes[SUBJECT_TAG] = remove_duplicates(subjects)

    if not people:
        if PERSON_TAG in data:
            if verbose:
                print(color(f" removing {PERSON_TAG}", fg='magenta'))
            if not dry_run:
                image.modify_xmp({PERSON_TAG: None})
    else:
        changes[PERSON_TAG] = remove_duplicates(people)

    if event is None:
        if EVENT_TAG in data:
            if verbose:
                print(color(f" removing old {EVENT_TAG}", fg='magenta'))
            if not dry_run:
                image.modify_xmp({EVENT_TAG: None})
    else:
        changes[EVENT_TAG] = {'lang="x-default"': event}

    # We got changes so write them back.
    if changes != {} and changes != old_changes:
        print(color(f" pushing changes", fg='green'))
        if verbose > 1:
            print(color(f"from\n{pp.pformat(old_changes)}", fg='cyan'))
            print(color(f"to\n{pp.pformat(changes)}", fg='green'))
        if not dry_run:
            image.modify_xmp(changes)

    if verbose:
        print(color(f" finished", style='bold', fg='green'))


config = Config(config_file)

if len(file_names) > 0:
    for file in file_names:
        try:
            if dump_xmp:
                dump_meta_data(file)
            else:
                tidy_meta_data(config, file)
        except Exception as e:
            print(color(f"{file}: error ({str(e)})", fg="red"))

else:
    print(args.base)
    path = args.base if args.base is not None else '.'
    event_handler = ExifFileHandler(config)
    config_event_handler = ConfigFileHandler(config)
    observer = Observer()
    observer.schedule(event_handler, path, recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)
            too_soon = set()
            with changed_files_lock:
                files = changed_files
                changed_files = set()
            for file in files:
                try:
                    if file_age(file) < 5:
                        if verbose:
                            print(color(f"{file}: too young", fg='yellow'))
                        too_soon.add(file)
                    else:
                        tidy_meta_data(config, file)
                except Exception as e:
                    print(color(f"{file}: error ({str(e)})", fg="red"))
            with changed_files_lock:
                changed_files = changed_files.union(too_soon)
    finally:
        observer.stop()
        observer.join()
